---
title: "[Gold IV] 단어 수학 - 1339 "
date: 2026-01-27
categories: [PS, BOJ] # BOJ, Programmers
tags: [그리디 알고리즘]
---

[문제 링크](https://www.acmicpc.net/problem/1339) 

## **풀이**
### 접근
브루트포스로 알파벳마다 일일이 숫자를 대입했다간 문제가 너무 복잡해 집니다. 그렇다면 문자의 위치마다 **가중치**를 준다면 어떨까요.

### 가중치
오른쪽 첫 문자부터 왼쪽 마지막 문자로 갈 때마다 가중치를 늘려갈 수 있습니다. 그리고 가중치가 높은 알파벳에 높은 숫자를 배정해야 전체 합이 최대가 됩니다.

### 정렬 + 그리디
가중치가 높은 알파벳에 높은 숫자를 배정하면 전체 합이 최대가 된다는 **그리디**함을 엿볼 수 있습니다. 그렇다면 **내림차순 정렬**을 통해 가중치를 정렬해 주고 그 가중치에 높은 값(9~0)를 곱한 뒤 더해주면 항상 최댓값이 나옵니다.


## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    n = int(input())
    words = [input().strip() for _ in range(n)]
    weight = {}
    for word in words:
        p = 1
        for c in word[::-1]:
            weight[c] = weight.get(c, 0)+p
            p *= 10
    vals = sorted(weight.values(), reverse=True)
    num = 9
    ans = 0
    for val in vals:
        ans += num*val
        num -= 1
    print(ans)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<string> words(n);
    for(int i = 0; i< n; i++) cin >> words[i];
    unordered_map<char, ll> weight;
    for(const string& word : words){
        ll p = 1;
        for(int i = word.length()-1; i >= 0; i--){
            weight[word[i]] += p;
            p *= 10;
        }
    }
    vector<ll> vals;
    for(auto &v: weight) vals.push_back(v.second);
    sort(vals.begin(), vals.end(), greater<>());
    int num = 9; ll ans = 0;
    for(ll val : vals){
        ans += num*val;
        num--;
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N \times L)$
* 공간복잡도: $\mathcal{O}(N \times L)$
