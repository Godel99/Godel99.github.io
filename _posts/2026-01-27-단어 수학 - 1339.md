---
title: "[Gold IV] 단어 수학 - 1339 "
date: 2026-01-27
categories: [PS, BOJ] # BOJ, Programmers
tags: [그리디 알고리즘]
---

[문제 링크](https://www.acmicpc.net/problem/1339) 

## 문제 설명

<p>민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.</p>

<p>단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.</p>

<p>예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.</p>

<p>N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.</p>

### 출력 

 <p>첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.</p>

## **풀이**
### 접근
브루트포스로 알파벳마다 일일이 숫자를 대입했다간 문제가 너무 복잡해 집니다. 그렇다면 문자의 위치마다 **가중치**를 준다면 어떨까요.

### 가중치
오른쪽 첫 문자부터 왼쪽 마지막 문자로 갈 때마다 가중치를 늘려갈 수 있습니다. 그리고 가중치가 높은 알파벳에 높은 숫자를 배정해야 전체 합이 최대가 됩니다.

### 정렬 + 그리디
가중치가 높은 알파벳에 높은 숫자를 배정하면 전체 합이 최대가 된다는 **그리디**함을 엿볼 수 있습니다. 그렇다면 **내림차순 정렬**을 통해 가중치를 정렬해 주고 그 가중치에 높은 값(9~0)를 곱한 뒤 더해주면 항상 최대값이 나옵니다.


## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    n = int(input())
    words = [input().strip() for _ in range(n)]
    weight = {}
    for word in words:
        p = 1
        for c in word[::-1]:
            weight[c] = weight.get(c, 0)+p
            p *= 10
    vals = sorted(weight.values(), reverse=True)
    num = 9
    ans = 0
    for val in vals:
        ans += num*val
        num -= 1
    print(ans)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<string> words(n);
    for(int i = 0; i< n; i++) cin >> words[i];
    unordered_map<char, ll> weight;
    for(const string& word : words){
        ll p = 1;
        for(int i = word.length()-1; i >= 0; i--){
            weight[word[i]] += p;
            p *= 10;
        }
    }
    vector<ll> vals;
    for(auto &v: weight) vals.push_back(v.second);
    sort(vals.begin(), vals.end(), greater<>());
    int num = 9; ll ans = 0;
    for(ll val : vals){
        ans += num*val;
        num--;
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N \times L)$
* 공간복잡도: $\mathcal{O}(N \times L)$
