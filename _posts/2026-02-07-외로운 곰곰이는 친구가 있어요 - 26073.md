---
title: "[Gold III] 외로운 곰곰이는 친구가 있어요 - 26073"
date: 2026-02-07
categories: [PS, BOJ] # BOJ, Programmers
tags: [수학, 정수론, 유클리드 호제법]
---
[문제 링크](https://www.acmicpc.net/problem/26073) 

## **풀이**
### 문제 요약
각 친구들의 이동할 수 있는 거리들로 파티에 올 수 있는지를 구하세요.

### 접근
이동 가능한 거리가 여러 개 주워지는데 그 거리들을 이용해서 파티(원점)에 올 수 있는지를 물어보는 문제입니다. 

두 이동을 조합해서 작은 단위의 이동을 만들 수 있다면, 그게 최선이 될 겁니다. 왜냐면 작은 단위로 움직여야 원하는 위치에 도착할 때 범위를 벗어나지 않을 수 있기 때문입니다.

### 작은 단위의 이동
예를 들어, 두 이동을 조합해 한 방향으로 8 이동 후 그 반대 방향으로 6 이동한다면 2라는 새로운 이동거리를 만들 수 있습니다. 두 이동 조합의 **최대공약수**가 바로 가장 작은 단위의 이동 거리가 됩니다.

### 증명
두 이동 $A=ag, \ B=bg$($a,\ b$는 서로소, $g$는 최대공약수)라고 한다면, $A$와 $B$를 어떻게 조합하던 $g$의 배수가 됩니다.

$1a, 2a,\cdots, ba$를 $b$로 나눈 나머지는 모두 다릅니다. 왜냐면 $a$와 $b$는 서로소이기 때문입니다. 만약 나머지가 같은 것이 존재한다면, 그 둘의 차는 반드시 $b$로 나누어떨어집니다.

$$
\begin{gathered}
ia=lb+c,\ ja=kb+c \\
ia-ja=(l-k) b \\
\end{gathered}
$$

에서 $l-k<b$이므로 $l-k$가 $b$로 나누어떨어질 수 없고 $a$ 또한 $b$와 서로소이므로 그 차가 반드시 $b$로 나누어떨어진다는 것과 모순됩니다. 그러므로 나머지는 모두 다릅니다. 그렇다면 나머지가 모두 다르므로 $b$로 나눈 나머지의 개수도 $b$개이므로, 0부터 $b-1$ 중에는 1이 반드시 존재하게 됩니다. 왜 하필 1에 집중하냐면 1이야말로 움직일 수 있는 가장 단위이기 때문입니다.

나머지가 1인 걸 $ca$라 한다면, $ca=db+1$로 나타낼 수 있고 $ca-db=1$이 됩니다. 여기다가 $g$를 곱하게 되면, $c(ag)-d(bg)=g$이고 다시 $cA-dB=g$가 됩니다. 즉, 최소 단위의 움직임이 **최대공약수**$\boldsymbol{g}$라는 것을 증명한 겁니다. $A$를 $c$번 움직이고 $B$를 $d$번 어떻게 움직이던 그 보폭은 최소 $g$만큼 이동한다는 것입니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

from math import gcd

def main():
    n = int(input())
    for _ in range(n):
        x, y = map(int, input().split())
        A = tuple(map(int, input().split()))
        g = 0
        for a in A[1:]: g = gcd(a, g)
        if x % g or y % g: print('Gave up')
        else: print('Ta-da')
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    while(n--){
        int x, y; cin >> x >> y;
        int k; cin >> k;
        int g = 0;
        for(int i = 0; i < k; i++){
            int a; cin >> a;
            g = gcd(a, g);
        }
        if(x%g || y%g) cout << "Gave up\n";
        else cout << "Ta-da\n";
    }
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N \times (K + \log(\max A_i)))$
* 공간복잡도: $\mathcal{O}(1)$
