---
title: "[Gold IV] Game of RUN - 33801"
date: 2026-02-04
categories: [PS, BOJ] # BOJ, Programmers
tags: [수학, 다이나믹 프로그래밍, 조합론]
---
[문제 링크](https://www.acmicpc.net/problem/33801) 

## **풀이**
### 접근
$N$칸의 1차원 바둑판에서 모든 돌이 잡히지 않도록 적절히 돌을 놓는 방법의 수를 구하라는 문제입니다. 

DP를 이용해서 왼쪽부터 지나서온 구간을 규칙을 어기지 않은 상태라 가정하고, 오른쪽 끝에 한 칸씩을 추가해 간다고 생각해 봅시다.

1차원 바둑판이기에 **마지막 칸의 상태만 분류**해도 돌이 잡히는지 아닌지를 판별할 수 있습니다.

### DP 정의

* $dp[i][s]$: 모든 돌이 잡히지 않고 $i$위치까지 $s$상태인 경우의 수

$s$상태는 아래와 같이 나타납니다.

### 상태 분류
1. 마지막 칸이 빈 경우
2. 마지막 칸에 흰 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있는 경우
3. 마지막 칸에 검은 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있는 경우
4. 마지막 칸에 흰 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있지 않는 경우
5. 마지막 칸에 검은 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있지 않는 경우

위와 같이 상태를 분류해 놓고 상태간의 전이과정을 이해해야 합니다.

### 전이
1. 1번 상태는 자기자신 1, 2, 3, 4, 5번 상태를 포함할 수 있습니다.
2. 2번 상태는 1, 2번 자기자신 상태를 포함합니다.
3. 3번 상태는 1, 3번 자기자신 상태를 포함합니다.
4. 4번 상태는 2, 4번 자기자신 상태를 포함합니다.
5. 5번 상태는 1, 5번 자기자신 상태를 포함합니다.

### 결과
4, 5번 상태는 빈 칸이 인접해있지 않기에 제외를 해주고 1, 2, 3번 상태 값을 더한 것이 정답이 됩니다.


## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

MOD = 1_000_000_007
dp = [[0] * 5 for _ in range(1000001)]

def main():
    dp[1][0] = 1
    dp[2][0] = 3
    dp[2][1] = dp[2][2] = dp[2][3] = dp[2][4] = 1
    for i in range(3, 1000001):
        dp[i][0] = (dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4])%MOD
        dp[i][1] = (dp[i-1][0]+dp[i-1][1])%MOD
        dp[i][2] = (dp[i-1][0]+dp[i-1][2])%MOD
        dp[i][3] = (dp[i-1][2]+dp[i-1][3])%MOD
        dp[i][4] = (dp[i-1][1]+dp[i-1][4])%MOD
    T = int(input())
    for _ in range(T):
        n = int(input()); print((dp[n][0]+dp[n][1]+dp[n][2])%MOD)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1'000'000'007;

ll dp[1000001][5];

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    dp[1][0] = 1;
    dp[2][0] = 3;
    dp[2][1] = dp[2][2] = dp[2][3] = dp[2][4] = 1;
    for(int i = 3; i <= 1000000; i++){
        dp[i][0] = (dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4])%MOD;
        dp[i][1] = (dp[i-1][0]+dp[i-1][1])%MOD;
        dp[i][2] = (dp[i-1][0]+dp[i-1][2])%MOD;
        dp[i][3] = (dp[i-1][2]+dp[i-1][3])%MOD;
        dp[i][4] = (dp[i-1][1]+dp[i-1][4])%MOD;
    }
    int T; cin >> T;
    for(int i = 0; i < T; i++){
        int n; cin >> n; cout << (dp[n][0]+dp[n][1]+dp[n][2])%MOD << '\n';
    }
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N_{max} + T)$
* 공간복잡도: $\mathcal{O}(N_{max})$
