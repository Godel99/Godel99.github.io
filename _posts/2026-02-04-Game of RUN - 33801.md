---
title: "[Gold IV] Game of RUN - 33801"
date: 2026-02-04
categories: [PS, BOJ] # BOJ, Programmers
tags: [수학, 다이나믹 프로그래밍, 조합론]
---
[문제 링크](https://www.acmicpc.net/problem/33801) 

## 문제 설명

<p>Game of RUN은 Game of Go(바둑)와 비슷하지만 2차원의 정사각형 격자 대신에 1차원 격자를 사용하는 2인용 게임이다.</p>

<p>Game of RUN의 규칙은 다음과 같다.</p>

<ul>
	<li>두 플레이어가 번갈아서 흑돌 또는 백돌을 격자 위에 원하는 만큼 놓는다. $0$개를 놓는 것도 허용된다.</li>
	<li>한 가지 색깔의 돌이 1칸 이상의 연속한 구간을 차지할 때 그 구간 전체를 그룹이라고 하자. 흑돌 3개가 연달아 놓여 있다면 그 중 흑돌 2개나 1개만을 포함하는 구간은 그룹이 아니다. 이때, 모든 그룹은 적어도 하나의 빈 칸과 이웃하고 있어야 한다. 예를 들어, 아래와 같은 경우들은 각각 흑돌의 그룹과 백돌의 그룹이 빈 칸과 이웃하고 있지 않으므로 올바른 게임 상태가 아니다.</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/89604c57-9fd5-4532-bbf8-15425c505721/-/preview/" style="height: 100px; width: 800px;"></p>

<p>길이 $n$인 게임판에서 가능한 모든 서로 다른 게임 상태의 수를 $1 000 000 007$로 나눈 나머지를 구하시오.</p>

### 입력 

 <p>첫 번째 줄에 테스트 케이스의 개수 $T$가 주어진다.</p>

<p>그다음 $T$줄에 걸쳐서 정수 $n$의 값이 한 줄에 하나씩 주어진다.</p>

### 출력 

 <p>각 테스트 케이스에 대해 문제의 정답을 한 줄에 출력한다.</p>

## **풀이**
### 접근
$N$칸의 1차원 바둑판에서 모든 돌이 잡히지 않도록 적절히 돌을 놓는 방법의 수를 구하라는 문제입니다. 

DP를 이용해서 지금까지 지나서온 왼쪽을 규칙을 어기지 않은 상태라 가정하고, 오른쪽에 **마지막 칸**을 한 칸씩 추가해서 상태를 분류합니다. 

### DP 정의

$$dp[i][s]:\ 규칙을\ 어기지\ 않고\ i위치까지\ s상태인\ 경우의\ 수$$ 

### 상태 분류
1. 마지막 칸이 빈 경우
2. 마지막 칸에 흰 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있는 경우
3. 마지막 칸에 검은 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있는 경우
4. 마지막 칸에 흰 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있지 않는 경우
5. 마지막 칸에 검은 돌이 들어있고, 그 돌이 포함된 그룹이 빈 칸과 인접해 있지 않는 경우

위와 같이 상태를 분류해 놓고 상태간의 전이과정을 이해해야 합니다.

### 전이
1. 1번 상태는 나머지 2, 3, 4, 5번 상태를 포함할 수 있습니다.
2. 2번 상태는 1, 2번 자기자신 상태를 포함합니다.
3. 3번 상태는 1, 3번 자기자신 상태를 포함합니다.
4. 4번 상태는 2, 4번 자기자신 상태를 포함합니다.
5. 5번 상태는 1, 5번 자기자신 상태를 포함합니다.

### 결과
4, 5번 상태는 빈 칸이 인접해있지 않기에 제외를 해주고 1, 2, 3번 상태 값을 더한 것이 정답이 됩니다.


## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

MOD = 1_000_000_007
dp = [[0] * 5 for _ in range(1000001)]

def main():
    dp[1][0] = 1
    dp[2][0] = 3
    dp[2][1] = dp[2][2] = dp[2][3] = dp[2][4] = 1
    for i in range(3, 1000001):
        dp[i][0] = (dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4])%MOD
        dp[i][1] = (dp[i-1][0]+dp[i-1][1])%MOD
        dp[i][2] = (dp[i-1][0]+dp[i-1][2])%MOD
        dp[i][3] = (dp[i-1][2]+dp[i-1][3])%MOD
        dp[i][4] = (dp[i-1][1]+dp[i-1][4])%MOD
    T = int(input())
    for _ in range(T):
        n = int(input()); print((dp[n][0]+dp[n][1]+dp[n][2])%MOD)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1'000'000'007;

ll dp[1000001][5];

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    dp[1][0] = 1;
    dp[2][0] = 3;
    dp[2][1] = dp[2][2] = dp[2][3] = dp[2][4] = 1;
    for(int i = 3; i <= 1000000; i++){
        dp[i][0] = (dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4])%MOD;
        dp[i][1] = (dp[i-1][0]+dp[i-1][1])%MOD;
        dp[i][2] = (dp[i-1][0]+dp[i-1][2])%MOD;
        dp[i][3] = (dp[i-1][2]+dp[i-1][3])%MOD;
        dp[i][4] = (dp[i-1][1]+dp[i-1][4])%MOD;
    }
    int T; cin >> T;
    for(int i = 0; i < T; i++){
        int n; cin >> n; cout << (dp[n][0]+dp[n][1]+dp[n][2])%MOD << '\n';
    }
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N_{max} + T)$
* 공간복잡도: $\mathcal{O}(N_{max})$
