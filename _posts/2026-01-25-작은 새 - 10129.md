---
title: "[Platinum II] 작은 새 - 10129"
date: 2026-01-25
categories: [PS, BOJ] # BOJ, Programmers
tags: [다이나믹 프로그래밍, 자료 구조, 덱, 덱을 이용한 구간 최댓값 트릭, 덱을 이용한 다이나믹 프로그래밍]
---

[문제 링크](https://www.acmicpc.net/problem/10129) 

## **풀이**

### 최적의 구간
DP를 이용해 모든 나무의 피로도를 구하는 방식은 비효율입니다. 

1. 나무 높이와 상관 없이 피로도가 가장 낮은 나무에서 출발하는 게 가장 좋습니다. 
2. 만약 피로도가 같다면, 가장 높은 나무에서 출발하는 게 가장 좋습니다.

위 2가지 관찰을 가지고 최적의 구간을 찾아봅시다.

### 단조성 유지
나무들을 타고 오른쪽으로 갈수록 피로도가 쌓이는 단조 증가 구조입니다.

그러므로 **맨 왼쪽 나무에서 나는 게 항상 최적**이 되도록 단조적 구간을 유지해 봅시다.

### 덱 이용
덱을 이용해 날아갈 수 있는 구간을 정해줍시다. 거리가 초과된 나무는 앞에서 제거하고, 새로 추가될 나무보다 불리한 나무는 뒤에서 제거해 주는 겁니다.


## **구현**
<details markdown="1">
<summary>코드</summary>
  
```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

from collections import deque

def main():
    n = int(input())
    h = list(map(int, input().split()))
    q = int(input())
    for _ in range(q):
        dp = deque()
        k = int(input())
        dp.append((0, 0, h[0]))
        for i in range(1, n):
            while dp and dp[0][0] + k < i: dp.popleft() 
            now = dp[0][1] + (1 if dp[0][2] <= h[i] else 0)
            while dp and (dp[-1][1] > now or dp[-1][1] == now and dp[-1][2] <= h[i]): dp.pop()
            dp.append((i, now, h[i]))
        print(dp[-1][1])
if __name__ == '__main__':
    main()
```
```c++
#include<bits/stdc++.h>
using namespace std;

struct st{
    int idx, val, h;
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    int q; cin >> q;

    while (q--){
        deque<st> dp;
        int k; cin >> k;

        dp.push_back({0,0,h[0]});

        for (int i = 1; i < n; i++){
            while (dp.size() && dp.front().idx + k < i) dp.pop_front();
            int now = dp.front().val + (bool)(dp.front().h <= h[i]);
            while (dp.size() && (dp.back().val > now || dp.back().val == now && dp.back().h <= h[i])) dp.pop_back();
            dp.push_back({i, now, h[i]});
        }
        cout << dp.back().val << '\n';
    }
}
```

### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(q × n)$
* 공간복잡도: $\mathcal{O}(n)$

</details>
