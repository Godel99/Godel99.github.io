---
title: "[Platinum II] 작은 새 - 10129"
date: 2026-01-25
categories: [PS, BOJ] # BOJ, Programmers
tags: [다이나믹 프로그래밍, 자료 구조, 덱, 덱을 이용한 구간 최댓값 트릭, 덱을 이용한 다이나믹 프로그래밍]
description: "Gödel's PS블로그"
---

[문제 링크](https://www.acmicpc.net/problem/10129) 
### 문제 설명

<p>경기과학고의 뒤뜰에는 일렬로 된 n개의 나무로 이루어진 숲이 있다. 그 중 첫 번째 나무 위에는 마지막 나무의 위로 올라가고 싶어하는 작은 새가 한 마리 있다. 그 새는 몸집이 매우 작기 때문에 한 번의 비행으로 날아갈 수 있는 거리에 한계가 있다. 만약 새가 i번째 나무 위에 있다면, 이 새는 한 번의 비행으로 i+1, i+2, …, i+k번째 나무 중 하나로 갈 수 있으며 그보다 멀리 떨어진 나무로는 가지 못한다.</p>

<p>또한, 작은 새에게 지금 있는 나무보다 높은 나무로 올라가는 일은 낮은 나무로 내려가는 일보다 더 힘든 일이다. 작은 새는 자기가 현재 위치한 나무보다 <strong>같거나 높은 </strong>높이의 나무로 날아가면 피로감을 느낀다고 한다.</p>

<p>작은 새의 목표는 자신이 <strong>피로감을 느끼는 횟수</strong>를 최소화하면서 마지막 나무에 도달하는 것이다. 또한, 이 작은 새에게는 똑같이 최소한의 피로로 마지막 나무로 가고 싶어 하는 친구 새들이 있으며 이들의 k값은 서로 다를 수 있다. 작은 새와 친구 새들이 그들의 목표를 달성할 수 있도록 도와주자.</p>

### 입력 

 <p>첫 번째 줄에는 나무의 수를 나타내는 정수 n (2 ≤ n ≤ 1,000,000)이 주어진다.</p>

<p>다음 줄에는 n개의 정수 d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n </sub>(1 ≤ d<sub>i</sub> ≤ 10<sup>9</sup>) 가 주어진다. d<sub>i</sub>는 i번째 나무의 높이를 의미한다.</p>

<p>세 번째 줄에는 마지막 나무로 날아가고 싶어하는 새의 수 q (1 ≤ q ≤ 25)가 주어진다.</p>

<p>다음 q개 줄 중 i번째 줄에는 i번째 새가 한 번의 비행으로 날아갈 수 있는 거리인 k<sub>i</sub> (1 ≤ k<sub>i</sub> ≤ n-1)가 주어진다.</p>

### 출력 

 <p>당신의 프로그램은 q줄에 걸쳐 답을 출력해야 한다. 출력의 i번째 줄에는 i번째 새가 마지막 나무에 도달할 때까지 피로감을 느끼는 횟수의 최솟값을 출력해야 한다.</p>

## **풀이**

### 최적의 구간
DP를 이용해 모든 나무의 피로도를 구하는 방식은 비효율입니다. 

1. 나무 높이와 상관 없이 피로도가 가장 낮은 나무에서 출발하는 게 가장 좋습니다. 
2. 만약 피로도가 같다면, 가장 높은 나무에서 출발하는 게 가장 좋습니다.

위 2가지 관찰을 가지고 최적의 구간을 찾아봅시다.

### 단조성 유지
나무들을 타고 오른쪽으로 갈수록 피로도가 쌓이는 단조 증가 구조입니다.

그러므로 **맨 왼쪽 나무에서 나는 게 항상 최적**이 되도록 구간을 조정해 봅시다.

### 덱 이용
덱을 이용해 날아갈 수 있는 구간을 정해줍시다. 거리가 초과된 나무는 앞에서 제거하고, 새로 추가될 나무보다 불리한 나무는 뒤에서 제거해 주는 겁니다.


## **구현**
<details markdown="1">
<summary>코드</summary>
  
```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

from collections import deque

def main():
    n = int(input())
    h = list(map(int, input().split()))
    q = int(input())
    for _ in range(q):
        dp = deque()
        k = int(input())
        dp.append((0, 0, h[0]))
        for i in range(1, n):
            while dp and dp[0][0] + k < i: dp.popleft() 
            now = dp[0][1] + (1 if dp[0][2] <= h[i] else 0)
            while dp and (dp[-1][1] > now or dp[-1][1] == now and dp[-1][2] <= h[i]): dp.pop()
            dp.append((i, now, h[i]))
        print(dp[-1][1])
if __name__ == '__main__':
    main()
```
```c++
#include<bits/stdc++.h>
using namespace std;

struct st{
    int idx, val, h;
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    int q; cin >> q;

    while (q--){
        deque<st> dp;
        int k; cin >> k;

        dp.push_back({0,0,h[0]});

        for (int i = 1; i < n; i++){
            while (dp.size() && dp.front().idx + k < i) dp.pop_front();
            int now = dp.front().val + (bool)(dp.front().h <= h[i]);
            while (dp.size() && (dp.back().val > now || dp.back().val == now && dp.back().h <= h[i])) dp.pop_back();
            dp.push_back({i, now, h[i]});
        }
        cout << dp.back().val << '\n';
    }
}
```

### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(q × n)$
* 공간복잡도: $\mathcal{O}(n)$

</details>
