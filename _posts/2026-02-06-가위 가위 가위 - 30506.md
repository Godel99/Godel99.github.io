---
title: "[Silver II] 가위 가위 가위 - 30506"
date: 2026-02-06
categories: [PS, BOJ] # BOJ, Programmers
tags: [차분 공격]
---
[문제 링크](https://www.acmicpc.net/problem/30506) 
### 문제 설명

<p>세종이는 가위바위보 머신을 개발했다. 머신을 작동시키면 머신 가위바위보 대결을 즐길 수 있다. 한 번의 대결은 총 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>번의 가위바위보 게임으로 이루어지며, 각 게임의 결과는 플레이어에게 공개되지 않는다. 대신 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>번의 가위바위보 게임을 모두 진행한 후 플레이어는 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>번의 게임 중 이긴 게임의 수를 알 수 있다.</p>

<p>가위바위보의 꽃은 무작위성이지만, 난수 생성 알고리즘을 믿지 못하는 세종이는 아예 머신이 낼 손 모양의 순서를 모두 고정해 버렸다. 이를 본 영재는 세종이와 다음과 같은 내기를 하기로 했다.</p>

<ul>
	<li>영재와 머신이 대결한다. 처음에 영재는 반드시 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>개의 가위를 낸다.</li>
	<li>매 대결이 끝날 때마다, 영재는 자신이 이긴 게임의 수를 확인한다. 그 뒤 영재는 낼 손 모양을 원하는 대로 바꾸고 다음 게임을 진행한다.</li>
	<li>영재는 첫 대결을 포함해 총 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>101</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$101$</span></mjx-container>번의 대결을 할 수 있다.</li>
	<li>대결 결과를 통해 영재가 머신의 손 모양이 무엇인지 맞히면 영재가, 맞히지 못하면 세종이가 내기에서 이긴다.</li>
</ul>

<p>영재가 내기에서 이길 수 있게 도와주자!</p>

### 입력 

 <p>첫째 줄에 영재가 머신과의 첫 대결에서 이긴 게임의 수를 나타내는 정수 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$K$</span></mjx-container>가 주어진다. <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$(0 \leq K \leq 100)$</span> </mjx-container></p>

### 출력 

 <p>다음을 표준 출력 스트림(<code>stdout</code>)으로 한 줄에 출력해 머신과의 대결을 진행할 수 있다.</p>

<ul>
	<li><code>? hand</code>: 영재의 손 모양을 <code>hand</code>로 바꾸고 다음 대결을 진행한다. <code>hand</code>는 <code>0</code>, <code>2</code>, <code>5</code>로만 이루어진 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>자 길이의 문자열이어야 한다. <code>hand</code>의 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$i$</span></mjx-container>번째 글자는 영재가 다음 대결의 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$i$</span></mjx-container>번째 게임에서 낼 손 모양을 의미하며, <code>0</code>은 바위, <code>2</code>는 가위, <code>5</code>는 보를 의미한다.</li>
</ul>

<p>출력한 후에는 반드시 표준 출력 버퍼를 비워야 한다. 출력 버퍼를 비우지 않는 경우 예상 밖의 결과를 얻을 수 있음에 유의하라.</p>

<p>대결의 결과는 영재가 이긴 게임의 수를 의미하는 하나의 정수로 주어진다. 만약 머신의 손 모양을 알아낸 경우, <code>! machine_hand</code>를 출력하고 프로그램을 종료할 수 있다. <code>machine_hand</code>는 머신의 손 모양을 뜻하는 문자열로, <code>0</code>, <code>2</code>, <code>5</code>로만 이루어진 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$100$</span></mjx-container>자 길이의 문자열이어야 한다. <code>machine_hand</code>의 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$i$</span></mjx-container>번째 글자는 머신이 한 대결의 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$i$</span></mjx-container>번째 게임에서 내는 손 모양을 의미하며, <code>0</code>은 바위, <code>2</code>는 가위, <code>5</code>는 보를 의미한다.</p>

<p>채점 프로그램은 <code>machine_hand</code>와 실제 머신이 내는 손 모양이 모두 일치할 때 이를 정답으로 처리한다. 만약 머신과의 대결 횟수가 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>101</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$101$</span></mjx-container>번을 초과하거나, 출력 형식을 지키지 않거나, <code>machine_hand</code>와 실제 머신이 내는 손 모양이 다른 경우 이를 오답으로 처리한다.</p>

<p>그레이더는 비적응적(non-adaptive)으로, 처음에 정한 손 모양을 상황에 따라 바꾸지 않는다.</p>

## **풀이**
### 접근
첫 판에 가위만 100번을 내서 기계와의 승수만을 가지고 다음 판에서 기계가 어떤 손 모양을 낼지 알아맞추는 문제입니다.

### 차분 공격이란?
**입력을 아주 조금만 바꿨을 때, 출력이 어떻게 달라지는지를 관찰해서 내부의 숨겨진 구조를 알아내는 방법**입니다. 

첫 판에서 가위만 내서 승률을 알아냈기에 다음판에 **바위를 한 번 내서 나온 승수를 통해 대결 결과가 다르게 나온다**는 것을 알 수 있습니다.

* 머신이 가위를 냈다면 : 처음에는 비겼는데 이번에는 이겼습니다. 이긴 횟수가 1 증가합니다.
* 머신이 바위를 냈다면 : 처음에는 졌는데 이번에는 비겼습니다. 이긴 횟수는 그대로입니다.
* 머신이 보를 냈다면 : 처음에는 이겼는데 이번에는 졌습니다. 이긴 횟수가 1 감소합니다.

이를 통해서 기계의 손 모양을 짐작할 수 있게 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    k = int(input())
    ans = ['0'] * 100
    hands = ['2'] * 100
    for i in range(100):
        hands[i] = '0'
        print('?', ''.join(hands))
        sys.stdout.flush()
        hands[i] = '2'
        newk = int(input())
        if k < newk: ans[i] = '2'
        elif k == newk: ans[i] = '0'
        else: ans[i] = '5'
    print('!', ''.join(ans))
    sys.stdout.flush()
if __name__ == '__main__':
    main()
```
```c++
#include<bits/stdc++.h>
using namespace std;
int ans[101];

int main(){
	int k, newk; cin >> k;
	for(int i = 1; i <= 100; i++){
		cout << "? ";
		for(int j = 1; j < i; j++) cout << 2;
		cout << 0;
		for(int j = i+1; j <= 100; j++) cout << 2;
		cout << endl;
		cin >> newk;
		if(k < newk) ans[i] = 2;
		else if(k == newk) ans[i] = 0;
		else ans[i] = 5;
	}
	cout << "! ";
	for(int i = 1; i <= 100; i++) cout << ans[i];
	cout << endl;
	return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N^2)$
* 공간복잡도: $\mathcal{O}(1)$
