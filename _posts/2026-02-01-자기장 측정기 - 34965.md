---
title: "[Gold V] 자기장 측정기 - 34965"
date: 2026-02-01
categories: [PS, BOJ] # BOJ, Programmers
tags: [구현, 문자열, 기하학, 시뮬레이션, 파싱]
---
[문제 링크](https://www.acmicpc.net/problem/34965) 

## **풀이**
### 접근
**나이브**하게 로봇의 경로마다 자기장 나오는 위치와 거리를 계산해서 매번 최소 거리를 찾을 때마다 갱신해 최솟값을 구할 수도 있습니다.

그러나 좀 더 나은 방법이 있습니다.

로봇은 오직 **평행 이동**만 가능합니다. 수직으로 이동하거나 수평으로 이동할 수 밖에 없으므로 이동은 항상 하나의 선분으로 나타납니다. 그렇다면 선분과 자기장이 나오는 위치와의 최소 거리 위치는 이동 경로 선분과 자기장이 나오는 위치와 **수직**이나 **수평**으로 만나거나, 만나지 않는다면 그 선분의 **양 끝점** 중 하나와 최소 거리를 이루게 됩니다.

그러므로 굳이 모든 경로와 거리를 계산할 필요가 없이 수직이나 수평의 거리와 이전 거리와의 최소만 비교해주면 그만입니다.

### 원점 이동
자기장 위치를 그대로 두고 계산해도 되지만, 좀 더 거리 계산을 쉽게 하기 위해서 좌표 전체의 원점을 자기장 위치로 이동 시킵니다. 그럼 자기장 위치가 원점이 됩니다.

$$
\begin{gathered}
(x, \ y): 기존\ 좌표 \\
(nx, \ ny): 이동\ 후\ 좌표 \\
(ax, \ ay): 최소\ 거리\ 좌표 \\
\end{gathered}
$$

### 예외 처리
자기장 위치가 원점이므로 이동 경로가 원점을 통과하면 -1을 출력하여 예외 처리해줘야 합니다. 마찬가지로 로봇은 평행 이동만 가능하므로 동시에 $x \times nx < 0$와 $y \times ny < 0$이 성립할 수 없으므로 함께 예외 처리를 해줍니다.

### 수직, 수평 구분
$x \times nx$를 통해 원점에서 그은 선이 이동 경로를 수직으로 통과하는지 검사하고, $y \times ny$를 통해 수평을 검사합니다. 이동 전과 이동 후 곱이 음수가 된다면 부호가 바뀌었다는 뜻이므로 원점에서 그은 선이 이동 경로를 통과한다는 것입니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def dist(x, y):
    x = abs(x); y = abs(y)
    return x*x + y*y

def main():
    sx, sy = map(int, input().split())
    if not sx and not sy: return int(not print(-1))
    s = input()
    dx = (1, 0, -1, 0); dy = (0, 1, 0, -1)
    x = -sx; y = -sy
    ax = x; ay = y
    idx = 0; dir = 0
    while idx < len(s):
        op = s[idx]; idx += 1
        d = 0
        while idx < len(s) and s[idx].isdigit(): d = d*10+int(s[idx]); idx += 1
        if op == 'S':
            nx = x+d*dx[dir]; ny = y+d*dy[dir]
            if x*nx <= 0 and y*ny <= 0: return int(not print(-1))
            if dist(nx, ny) < dist(ax, ay): ax = nx; ay = ny
            if x*nx < 0: 
                if dist(0, y) < dist(ax, ay): ax = 0; ay = y
            if y*ny < 0:
                if dist(x, 0) < dist(ax, ay): ax = x; ay = 0
            x = nx; y = ny
        if op == 'T':
            dir += d; dir %= 4
    print(ax+sx, ay+sy)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using lll = __int128;
const lll INF = LLONG_MAX;

lll dist(lll x, lll y){
    if(x < 0) x = -x; if(y < 0) y = -y;
    if(x > 2'000'000'000LL || y > 2'000'000'000LL) return INF;
    return x*x + y*y;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};
    ll sx, sy; cin >> sx >> sy; if(!sx && !sy) return !(cout << -1);
    lll x = -sx, y = -sy;
    lll ax = x, ay = y;
    string s; cin >> s;
    int idx = 0, dir = 0;
    while(idx < s.length()){
        char op = s[idx++];
        int d = 0;
        while(isdigit(s[idx])) d = d*10+s[idx++]-'0';
        if(op == 'S'){
            ll nx = x+d*dx[dir], ny = y+d*dy[dir];
            if(x*nx <= 0 && y*ny <= 0) return !(cout << -1);
            if(dist(nx, ny) < dist(ax, ay)) ax = nx, ay = ny;
            if(x*nx < 0) if(dist(0, y) < dist(ax, ay)) ax = 0, ay = y;
            if(y*ny < 0) if(dist(x, 0) < dist(ax, ay)) ax = x, ay = 0;
            x = nx, y = ny;
        }
        if(op == 'T'){
            dir += d, dir %= 4;
        }
    }
    cout << (ll)(ax+sx) << ' ' << (ll)(ay+sy);
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(L)$
* 공간복잡도: $\mathcal{O}(L)$
