---
title: "[Gold I] 트리 수정 - 12912"
date: 2026-01-26
categories: [PS, BOJ] # BOJ, Programmers
tags: [그래프 이론, 브루트포스 알고리즘, 그래프 탐색, 트리, 깊이 우선 탐색]
---
[문제 링크](https://www.acmicpc.net/problem/12912)

## 문제 설명

<p>N개의 정점으로 이루어진 트리 T가 있다. 트리의 각 정점은 0번부터 N-1번까지 번호가 매겨져 있다.</p>

<ul>
	<li>트리에서 임의의 두 정점을 연결하는 단순 경로의 개수는 1개이다.</li>
	<li>두 정점사이의 거리는 두 정점을 연결하는 단순 경로상에 있는 간선의 가중치의 합이다.</li>
	<li>트리의 지름은 트리에 존재하는 모든 경로 중에서 가장 긴 것이다.</li>
</ul>

<p>홍준이는 T에서 간선을 하나 제거하고, 간선을 하나 추가하려고 한다. 이때, 추가하는 간선의 가중치는 제거한 간선의 가중치와 같아야 하며, 간선을 추가한 이후에도 트리를 유지해야 한다.</p>

<p>이때, 홍준이가 만들 수 있는 트리 중에서 지름이 가장 큰 것을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 트리 정점의 개수 N이 주어진다. (2 ≤ N ≤ 2,000)</p>

<p>둘째 줄부터 N-1개의 줄에는 트리를 이루는 간선이 주어진다. 간선은 from, to, cost와 같이 세 가지 정수로 이루어져 있으며, from과 to를 연결하는 간선의 가중치가 cost라는 뜻이다. (1 ≤ cost ≤ 1,000,000,000)</p>

### 출력 

 <p>첫째 줄에 홍준이가 만들 수 있는 트리 중에서 가장 지름이 큰 것의 지름을 출력한다.</p>

## **풀이**

### 접근
간단하게 그래프를 먼저 구현합시다. 그래프를 통해 노드간에 지름을 구하고 지름+지름+간선의 길이의 최댓값을 구하면 됩니다.

### 지름
DFS로 어느 한 노드에서 가장 멀리 있는 노드까지 가고, 그 노드로부터 다시 가장 멀리 있는 노드까지 가면 **지름**을 구할 수 있습니다.

### 지름+지름+간선 최대값
모든 간선에 대해서 지름을 구해 간선까지 더한 합을 비교해 최댓값을 갱신하며 찾아주면 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    N = int(input())
    graph = [[] for _ in range(N)]
    edges = []
    for _ in range(N-1):
        u, v, w = map(int, input().split())
        edges.append((u, v, w))
        graph[u].append((v, w))
        graph[v].append((u, w)) 
    def DFS(start, pre, blocked_edge):
        visited = [False] * N
        stack = [(start, 0)]
        visited[start] = True
        node = start
        max_dist = 0
        while stack:
            cur, dist = stack.pop()
            if dist > max_dist:
                max_dist = dist
                node = cur
            for nxt, w in graph[cur]:
                if nxt == pre:
                    continue
                if nxt == blocked_edge:
                    continue
                if not visited[nxt]:
                    visited[nxt] = True
                    stack.append((nxt, dist + w))
        return node, max_dist
    answer = 0
    for u, v, w in edges:
        answer = max(answer, DFS(DFS(u, v, v)[0], v, v)[1] + w + DFS(DFS(v, u, u)[0], u, u)[1])
    print(answer)
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pll = pair<ll, ll>;

int N;
vector<vector<pll>> graph;
vector<tuple<int, int, int>> edges;

pll DFS(int start, int pre, int blocked_edge){
    vector<bool> visited(N, false);
    stack<pll> st;
    st.push({start, 0});
    visited[start] = true;
    int node = start;
    ll max_dist = 0;
    while (!st.empty()){
        auto [cur, dist] = st.top(); st.pop();
        if (dist > max_dist){
            max_dist = dist;
            node = cur;
        }
        for (auto [nxt, w] : graph[cur]) {
            if (nxt == pre) continue;
            if (nxt == blocked_edge) continue;
            if (!visited[nxt]){
                visited[nxt] = true;
                st.push({nxt, dist + w});
            }
        }
    }
    return {node, max_dist};
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    cin >> N;
    graph.resize(N);
    for (int i = 0; i < N-1; i++){
        int u, v; ll w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
        graph[u].push_back({v,w});
        graph[v].push_back({u,w});
    }
    ll answer = 0;
    for (auto [u,v,w] : edges){
        answer = max(answer, DFS(DFS(u,v,v).first, v, v).second + w + DFS(DFS(v,u,u).first, u,u).second);
    }
    cout << answer;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N²)$
* 공간복잡도: $\mathcal{O}(N)$

</details>
