---
title: "[Gold I] 트리 수정 - 12912"
date: 2026-01-26
categories: [PS, BOJ] # BOJ, Programmers
tags: [그래프 이론, 브루트포스 알고리즘, 그래프 탐색, 트리, 깊이 우선 탐색]
---
[문제 링크](https://www.acmicpc.net/problem/12912)

## **풀이**

### 접근
간단하게 그래프를 먼저 구현합시다. 그래프를 통해 노드간에 지름을 구하고 지름+지름+간선의 길이의 최댓값을 구하면 됩니다.

### 지름
DFS로 어느 한 노드에서 가장 멀리 있는 노드까지 가고, 그 노드로부터 다시 가장 멀리 있는 노드까지 가면 **지름**을 구할 수 있습니다.

### 지름+지름+간선 최대값
모든 간선에 대해서 지름을 구해 간선까지 더한 합을 비교해 최댓값을 갱신하며 찾아주면 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    N = int(input())
    graph = [[] for _ in range(N)]
    edges = []
    for _ in range(N-1):
        u, v, w = map(int, input().split())
        edges.append((u, v, w))
        graph[u].append((v, w))
        graph[v].append((u, w)) 
    def DFS(start, pre, blocked_edge):
        visited = [False] * N
        stack = [(start, 0)]
        visited[start] = True
        node = start
        max_dist = 0
        while stack:
            cur, dist = stack.pop()
            if dist > max_dist:
                max_dist = dist
                node = cur
            for nxt, w in graph[cur]:
                if nxt == pre:
                    continue
                if nxt == blocked_edge:
                    continue
                if not visited[nxt]:
                    visited[nxt] = True
                    stack.append((nxt, dist + w))
        return node, max_dist
    answer = 0
    for u, v, w in edges:
        answer = max(answer, DFS(DFS(u, v, v)[0], v, v)[1] + w + DFS(DFS(v, u, u)[0], u, u)[1])
    print(answer)
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pll = pair<ll, ll>;

int N;
vector<vector<pll>> graph;
vector<tuple<int, int, int>> edges;

pll DFS(int start, int pre, int blocked_edge){
    vector<bool> visited(N, false);
    stack<pll> st;
    st.push({start, 0});
    visited[start] = true;
    int node = start;
    ll max_dist = 0;
    while (!st.empty()){
        auto [cur, dist] = st.top(); st.pop();
        if (dist > max_dist){
            max_dist = dist;
            node = cur;
        }
        for (auto [nxt, w] : graph[cur]) {
            if (nxt == pre) continue;
            if (nxt == blocked_edge) continue;
            if (!visited[nxt]){
                visited[nxt] = true;
                st.push({nxt, dist + w});
            }
        }
    }
    return {node, max_dist};
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    cin >> N;
    graph.resize(N);
    for (int i = 0; i < N-1; i++){
        int u, v; ll w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
        graph[u].push_back({v,w});
        graph[v].push_back({u,w});
    }
    ll answer = 0;
    for (auto [u,v,w] : edges){
        answer = max(answer, DFS(DFS(u,v,v).first, v, v).second + w + DFS(DFS(v,u,u).first, u,u).second);
    }
    cout << answer;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N²)$
* 공간복잡도: $\mathcal{O}(N)$

</details>
