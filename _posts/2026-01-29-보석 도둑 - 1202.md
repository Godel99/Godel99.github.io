---
title: "[Gold II] 보석 도둑 - 1202"
date: 2026-01-29
categories: [PS, BOJ] # BOJ, Programmers
tags: [자료 구조, 그리디 알고리즘, 정렬, 우선순위 큐]
---
[문제 링크](https://www.acmicpc.net/problem/1202) 

## 문제 설명

<p>세계적인 도둑 상덕이는 보석점을 털기로 결심했다.</p>

<p>상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 M<sub>i</sub>와 가격 V<sub>i</sub>를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 C<sub>i</sub>이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.</p>

<p>상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)</p>

<p>다음 N개 줄에는 각 보석의 정보 M<sub>i</sub>와 V<sub>i</sub>가 주어진다. (0 ≤ M<sub>i</sub>, V<sub>i</sub> ≤ 1,000,000)</p>

<p>다음 K개 줄에는 가방에 담을 수 있는 최대 무게 C<sub>i</sub>가 주어진다. (1 ≤ C<sub>i</sub> ≤ 100,000,000)</p>

<p>모든 숫자는 양의 정수이다.</p>

### 출력 

 <p>첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.</p>

## **풀이**

### 접근
가방에 보석을 담아서 가져올 수 있느냐가 중요합니다. 그렇다면 가방의 무게를 기준으로 생각해 봅시다.

### 전환
가방에 하나의 보석만 들어갈 수 있지만, 조금 관점을 뒤집어 가방에 들어갈 수 있는 모든 보석을 다 넣고 거기서 가장 값어치 있는 보석을 꺼내도 보석의 최대 가격에 **그리디**하게 도달할 수 있습니다.

### 정렬
가방의 무게를 기준으로 보석의 무게도 함께 오름차순 정렬 후 담을 수 있는 모든 보석을 가방에 넣고 그 중 가장 값어치 있는 보석을 꺼냅시다.

모든 가방에서 대해서 반복하면 정답이 도출됩니다.


## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

import heapq

def main():
    n, k = map(int, input().split())
    gems = sorted([tuple(map(int, input().split())) for _ in range(n)])
    bags = sorted(int(input()) for _ in range(k))
    hq = []
    idx = ans = 0
    for bag in bags:
        while idx < n and gems[idx][0] <= bag:
            heapq.heappush(hq, -gems[idx][1])
            idx += 1
        if hq: ans += -heapq.heappop(hq)
    print(ans)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, k; cin >> n >> k;
    vector<pii> gems(n);
    for(int i = 0; i < n; i++) cin >> gems[i].first >> gems[i].second;
    vector<ll> bags(k);
    for(int i = 0; i < k; i++) cin >> bags[i];
    sort(gems.begin(), gems.end());
    sort(bags.begin(), bags.end());
    priority_queue<int, vector<int>> pq;
    int idx = 0; ll ans =0;
    for(auto& bag: bags){
        while(idx < n && gems[idx].first <= bag){
            pq.push(gems[idx].second);
            idx++;
        }  
        if(!pq.empty()){
            ans += pq.top(); pq.pop();
        }
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}((n + k) \log n)$
* 공간복잡도: $\mathcal{O}(n+k)$
