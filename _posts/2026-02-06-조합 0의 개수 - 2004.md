---
title: "[Silver II] 조합 0의 개수 - 2004 "
date: 2026-02-06
categories: [PS, BOJ] # BOJ, Programmers
tags: [수학, 정수론]
---
[문제 링크](https://www.acmicpc.net/problem/2004) 

## **풀이**
### 접근
조합 $\binom{n}{r}$ 값의 0의 개수를 구하라는 문제입니다.

어떤 수의 0의 구성 요건은 그 수를 소인수분해 했을 때 **2와 5**의 곱으로 나타나게 됩니다. 그 둘을 하나의 쌍으로 생각하고 2와 5의 개수 중 **작은 쪽**이 0의 개수를 결정하게 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    n, m = map(int , input().split())
    def cp(n, m):
        cnt = 0
        while n >= m:
            n //= m
            cnt += n
        return cnt
    cnt2 = cp(n, 2)-cp(m, 2)-cp(n-m, 2)
    cnt5 = cp(n, 5)-cp(m, 5)-cp(n-m, 5)
    print(min(cnt2, cnt5))
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int cp(ll n, ll m){
    int cnt = 0;
    while(n >= m){
        n /= m;
        cnt += n;
    }
    return cnt;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    ll n, m; cin >> n >> m;
    int cnt2 = cp(n, 2)-cp(m, 2)-cp(n-m, 2);
    int cnt5 = cp(n, 5)-cp(m, 5)-cp(n-m, 5);
    cout << min(cnt2, cnt5);
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(\log N)$
* 공간복잡도: $\mathcal{O}(1)$
