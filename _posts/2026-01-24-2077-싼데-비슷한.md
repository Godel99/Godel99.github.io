---
title: "[Gold II] 싼데 비슷한 - 2077"
date: 2026-01-24
categories: [PS, BOJ]
tags: [수학, 애드 혹, 해 구성하기, 역추적, 비둘기집 원리]
---

[문제 링크](https://www.acmicpc.net/problem/2077) 

## **풀이**
### 접근
DP로 접근해도 되지만, 주어진 메모리가 적기 때문에 DP로 접근해서는 문제를 풀 수 없습니다. 또한 최소 광물 손해를 구하는 게 아닌 75% 광물을 취득할 수 있느냐를 묻는 문제이기에 굳이 DP로 접근할 필요가 없습니다.

### 비둘기집의 원리
문제 조건을 보면 광물이 고르게 퍼져 있다는 것을 알 수 있습니다. 즉, 한 곳에 집중적으로 광물이 존재하지 않습니다. 또한 기계는 총 4칸 중 한 칸을 포기하고 3칸에서 광물 채굴이 가능합니다. 따라서, 실은 항상 75% 이상 광물을 채취할 수 있습니다. 여기서 수학적 원리 하나가 나오게 됩니다.

**비둘기집의 원리: $n$개의 비둘기집에 $n+1$마리 이상의 비둘기가 들어갈 때, 최소한 한 집에는 2마리 이상의 비둘기가 반드시 들어간다는 조합론적 원리**입니다.

비둘기집 원리를 이용해 전 구간을 **4등분**해서 생각해 볼 수 있습니다. 그 중 가장 적은 광물을 수학환 곳을 제외해도 비둘기집 원리에 의해 무조건 75%이상의 광물을 얻을 수 있습니다. 등분한 구간 중 가장 적은 광물을 가진 곳을 제외해 그 점을 시작점으로 둡시다.

### 시작점
제외한 구간을 **시작점**으로 잡고 나머지 구간을 모든 기계가 3곳에서 광물을 채취하면 75% 이상 광물을 얻을 수 있습니다. 

## **구현**
<details markdown="1">
<summary>코드</summary>

```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll S[4];

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int T; cin >> T; while(T--){
        cout << "YES\n";
        int n; cin >> n; S[0] = S[1] = S[2] = S[3] = 0;
        for(int i = 1; i <= n; i++){
            int t; cin >> t; S[i&3] += t;
        }
        ll m = min({S[0], S[1], S[2], S[3]});
        if(S[2] == m){
            cout << "0"; n--;
        }
        else if(S[3] == m){
            cout << "01"; n -= 2;
        }
        else if(S[0] == m){
            cout << "022"; n -= 3;
        }
        while(n >= 4){
            n -= 4; cout << "0333";
        }
        if(n) cout << 0;
        if(n == 2) cout << 1;
        if(n == 3) cout << 22;
        cout << '\n';
    }
}
```

### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n)$
* 공간복잡도: $\mathcal{O}(1)$

</details>




































