---
title: "[Gold III] 벽 부수고 이동하기 - 2206"
date: 2026-02-04
categories: [PS, BOJ] # BOJ, Programmers
tags: [그래프 이론, 그래프 탐색, 너비 우선 탐색, 격자 그래프]
---
[문제 링크](https://www.acmicpc.net/problem/2206) 

## 문제 설명

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.</p>

<p>만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.</p>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

<p>맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.</p>

### 출력 

 <p>첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.</p>

## **풀이**
### 접근
최단 거리를 구하는 문제입니다. 경로의 가중치는 없으므로 다익스트라가 아닌 **DP와 BFS**만으로 충분히 풀 수 있습니다. 다만, 벽을 한 번만 부술 수 있다는 조건 때문에 DP에 상태 분기가 하나 더 필요합니다.

이동 시 범위 확인만 조심해 주면 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): return sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

from collections import deque
dx = (1, 0, -1, 0); dy = (0, 1, 0, -1)

def main():
    n, m = map(int, input().split())
    board = [list(input()) for _ in range(n)]
    dp = [[[0]*2 for _ in range(m)] for _ in range(n)]
    dp[0][0][0] = 1
    dq = deque([(0, 0, 0)])
    while dq:
        x, y, b = dq.popleft()
        if x == n-1 and y == m-1: return int(not print(dp[x][y][b]))
        for dir in range(4):
            nx = x+dx[dir]; ny = y+dy[dir]
            if nx < 0 or nx >= n or ny < 0 or ny >= m: continue
            if board[nx][ny] == '0' and dp[nx][ny][b] == 0:
                dp[nx][ny][b] = dp[x][y][b]+1 
                dq.append((nx, ny, b))
            if board[nx][ny] == '1' and b == 0 and dp[nx][ny][1] == 0:
                dp[nx][ny][1] = dp[x][y][b]+1
                dq.append((nx, ny, 1))
    print(-1)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ai3 = array<int, 3>;

int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, m; cin >> n >> m;
    vector<vector<char>> board(n, vector<char>(m));
    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> board[i][j];
    vector<vector<array<int,2>>> dp(n, vector<array<int,2>>(m, {0, 0}));
    dp[0][0][0] = 1;
    deque<ai3> dq;
    dq.push_back({0, 0, 0});
    while(!dq.empty()){
        auto[x, y, b] = dq.front(); dq.pop_front();
        if(x == n-1 && y == m-1) return !(cout << dp[x][y][b]);
        for(int dir = 0; dir < 4; dir++){
            int nx = x+dx[dir], ny = y+dy[dir];
            if (nx < 0 or nx >= n or ny < 0 or ny >= m) continue;
            if(board[nx][ny] == '0' && dp[nx][ny][b] == 0){
                dp[nx][ny][b] = dp[x][y][b]+1;
                dq.push_back({nx, ny, b});
            }
            if(board[nx][ny] == '1' && b == 0 && dp[nx][ny][1] == 0){
                dp[nx][ny][1] = dp[x][y][b]+1;
                dq.push_back({nx, ny, 1});
            }
        }
    }
    cout << -1;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N \times M)$
* 공간복잡도: $\mathcal{O}(N \times M)$
