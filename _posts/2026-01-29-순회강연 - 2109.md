---
title: "[Gold III] 순회강연 - 2109"
date: 2026-01-29
categories: [PS, BOJ] # BOJ, Programmers
tags: [자료 구조, 그리디 알고리즘, 정렬, 우선순위 큐]
---
[문제 링크](https://www.acmicpc.net/problem/2109) 

## 문제 설명

<p>한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.</p>

<p>예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.</p>

### 입력 

 <p>첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.</p>

### 출력 

 <p>첫째 줄에 최대로 벌 수 있는 돈을 출력한다.</p>

## **풀이**
### 접근
하루에 하나의 강의만 가능하고 마감일 d 이전까지는 아무 날에나 강연이 가능합니다. 그러므로 마감일이 높을수록 선택지가 많아집니다.

그렇다면 **마감일을 기준**에서 문제를 생각해 봐야 합니다.

### 정렬 + 그리디
일단 마감일을 기준으로 **정렬**을 해 봅시다. 마감일 기준으로 정렬 후 가장 높은 강연료를 찾기 보다 가장 적은 강연료의 강의를 빼버린다면, **그리디**하게 마감일 기준 가장 높은 강연료의 강의만 남게 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

import heapq

def main():
    n = int(input())
    l = sorted([tuple(map(int, input().split())) for _ in range(n)], key=lambda x: x[1])
    hq = []
    for p, d in l:
        heapq.heappush(hq, p)
        if len(hq) > d: heapq.heappop(hq)
    print(sum(hq))
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
using pii=pair<int, int>;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<pii> l(n);
    for(int i = 0; i < n; i++) cin >> l[i].first >> l[i].second;
    sort(l.begin(), l.end(), [](auto& a, auto& b){
        return a.second < b.second;
    });
    priority_queue<int, vector<int>, greater<int>> pq;
    for(auto& [p, d]: l){
        pq.push(p);
        if(pq.size() > d) pq.pop();
    }
    int ans = 0;
    while(!pq.empty()){
        ans += pq.top();
        pq.pop();
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n \log n)$
* 공간복잡도: $\mathcal{O}(n)$
