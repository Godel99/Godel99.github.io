---
title: "[Gold III] 순회강연 - 2109"
date: 2026-01-29
categories: [PS, BOJ] # BOJ, Programmers
tags: [자료 구조, 그리디 알고리즘, 정렬, 우선순위 큐]
---
[문제 링크](https://www.acmicpc.net/problem/2109) 

## **풀이**
### 접근
하루에 하나의 강의만 가능하고 마감일 d 이전까지는 아무 날에나 강연이 가능합니다. 그러므로 마감일이 높을수록 선택지가 많아집니다.

그렇다면 **마감일을 기준**에서 문제를 생각해 봐야 합니다.

### 정렬 + 그리디
일단 마감일을 기준으로 **정렬**을 해 봅시다. 마감일 기준으로 정렬 후 가장 높은 강연료를 찾기 보다 가장 적은 강연료의 강의를 빼버린다면, **그리디**하게 마감일 기준 가장 높은 강연료의 강의만 남게 됩니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

import heapq

def main():
    n = int(input())
    l = sorted([tuple(map(int, input().split())) for _ in range(n)], key=lambda x: x[1])
    hq = []
    for p, d in l:
        heapq.heappush(hq, p)
        if len(hq) > d: heapq.heappop(hq)
    print(sum(hq))
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
using pii=pair<int, int>;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<pii> l(n);
    for(int i = 0; i < n; i++) cin >> l[i].first >> l[i].second;
    sort(l.begin(), l.end(), [](auto& a, auto& b){
        return a.second < b.second;
    });
    priority_queue<int, vector<int>, greater<int>> pq;
    for(auto& [p, d]: l){
        pq.push(p);
        if(pq.size() > d) pq.pop();
    }
    int ans = 0;
    while(!pq.empty()){
        ans += pq.top();
        pq.pop();
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n \log n)$
* 공간복잡도: $\mathcal{O}(n)$
