---
title: "[Gold III] 연산자 파티 2 - 28142 "
date: 2026-01-28
categories: [PS, BOJ] # BOJ, Programmers
tags: [수학, 애드 혹, 비트마스킹, 분할 정복을 이용한 거듭제곱, 런타임 전의 전처리]
---

[문제 링크](https://www.acmicpc.net/problem/28142) 

## **풀이**
### 접근
문제 자체가 어려운 것은 아닙니다. 제시한대로 그대로 구현을 해도 논리적으로 문제될 것은 없습니다. 다만, 이 문제는 시간 제한 때문에 좀 더 효율적 방법을 요구합니다.

그렇다면 어떻게 연산을 줄일 수 없을까요.

### 연산 줄이기
비트연산을 해보면 $x \wedge i=i, x \vee i=i$ 된다는 것을 알 수 있습니다. 

비트연산은 3과 15의 최소공배수인 **255배수**마다 이뤄지므로 $i=1$부터 시작하지말고 $N$ 이하의 가장 큰 255의 배수부터 시작해도 같은 결괏값을 얻을 수 있습니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    mod = 1000000007
    n = int(input())
    l = n - n % 255
    x = 0
    for i in range(l, n+1):
        x -= i
        x = abs(x)
        if i % 3 == 0: x = (x * i) % mod
        if i % 15 == 0: x &= i
        if i % 63 == 0: x ^= i
        if i % 255 == 0: x |= i
        if i % 1023 == 0: x = (x * pow(2, i, mod)) % mod
    print(x)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const ll mod=1e9+7;
ll pw(ll n){
    ll ret=1,a=2;
    while(n){
        if(n&1)ret=ret*a%mod;
        a=a*a%mod;
        n>>=1;
    } return ret;
}
int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    ll x = 0, n, l; cin >> n;
    l = n-n%255;
    for(ll i = l; i <= n; i++){
        x -= i; 
        if(x < 0) x = -x;
        if(i%3 == 0) x = (x%mod)*(i%mod)%mod;
        if(i%15 == 0) x &= i;
        if(i%63 == 0) x ^= i;
        if(i%255 == 0) x |= i;
        if(i%1023 == 0) x = x%mod*pw(i)%mod;
    } cout << x;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(1)$
* 공간복잡도: $\mathcal{O}(1)$
