---
title: "[Gold I] 택배 - 8980"
date: 2026-01-31
categories: [PS, BOJ] # BOJ, Programmers
tags: [그리디 알고리즘, 정렬]
---
[문제 링크](https://www.acmicpc.net/problem/8980) 

## **풀이**
### 접근
핵심은 **이동 구간 동안 용량을 얼마나 오래 잡아먹느냐**입니다.

그러기에 멀리가는 택배보다 빨리 처리할 수 있는 택배를 먼저 배달하는 게 가장 최선이라는 **그리디**를 발견할 수 있습니다.

### 정렬
가장 가까운 곳부터 배달하는 게 가장 빠르므로 **도착 마을 기준으로 오름차순 정렬**을 합니다.

### 구간 용량 설정
택배를 관리하기 위해서 구간 배열을 만들어서 관리해 줍니다. 각 마을단위로 트럭이 실은 용량의 **최대 사용량** 찾아 트럭이 실을 수 있는 용량에서 빼준 용량과 마을에서 요구하는 용량의 **최솟값**을 트럭에 실어줍니다.

트럭에 가장 빠르게 배달할 수 있는 택배를 실었다면 구간에도 적용해서 용량을 갱신해 줍니다.

### 세그먼트 트리 + Lazy Propagation
최대 사용량과 구간 값 수정을 **세그먼트 트리 + Lazy Propagation**를 통해 구현한다면 $\mathcal{O}(\log N)$로 더 빠르게 실행이 가능합니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    n, c = map(int, input().split())
    m = int(input())
    d = sorted([tuple(map(int, input().split())) for _ in range(m)], key=lambda x: x[1])
    cap = [0] * (n+1)
    ans = 0
    for s, e, w in d:
        can = min(w, c-max(cap[s:e]))
        for i in range(s, e): cap[i] += can
        ans += can
    print(ans)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using aiii = array<int, 3>;

struct SegTree {
    int n;
    vector<int> tree, lazy;
    SegTree(int n) : n(n) {
        tree.assign(4*n, 0);
        lazy.assign(4*n, 0);
    }

    void push(int node) {
        if (lazy[node] != 0) {
            for (int nxt : {node*2, node*2+1}) {
                tree[nxt] += lazy[node];
                lazy[nxt] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void range_add(int node, int l, int r, int ql, int qr, int val) {
        if (qr < l || r < ql) return;
        if (ql <= l && r <= qr) {
            tree[node] += val;
            lazy[node] += val;
            return;
        }
        push(node);
        int mid = (l + r) / 2;
        range_add(node*2, l, mid, ql, qr, val);
        range_add(node*2+1, mid+1, r, ql, qr, val);
        tree[node] = max(tree[node*2], tree[node*2+1]);
    }

    int query_max(int node, int l, int r, int ql, int qr) {
        if (qr < l || r < ql) return 0;
        if (ql <= l && r <= qr) return tree[node];
        push(node);
        int mid = (l + r) / 2;
        return max(
            query_max(node*2, l, mid, ql, qr),
            query_max(node*2+1, mid+1, r, ql, qr)
        );
    }
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, c, m; cin >> n >> c >> m;
    vector<aiii> d(m);
    for(int i = 0; i < m; i++) cin >> d[i][0] >> d[i][1] >> d[i][2];
    sort(d.begin(), d.end(), [](const aiii& a, const aiii& b){
        return a[1] < b[1];
    });
    SegTree seg(n);
    int ans = 0;
    for(auto &[s, e, w]: d){
        int mx = seg.query_max(1, 1, n, s, e-1);
        int can = min(w, c-mx);
        seg.range_add(1, 1, n, s, e-1, can);
        ans += can;
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(M·log N)$
* 공간복잡도: $\mathcal{O}(4N)$
