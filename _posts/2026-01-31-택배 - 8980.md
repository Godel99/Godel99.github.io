---
title: "[Gold I] 택배 - 8980"
date: 2026-01-31
categories: [PS, BOJ] # BOJ, Programmers
tags: [그리디 알고리즘, 정렬]
---
[문제 링크](https://www.acmicpc.net/problem/8980) 

## 문제 설명

<p>아래 그림과 같이 직선 도로상에 왼쪽부터 오른쪽으로 1번부터 차례대로 번호가 붙여진 마을들이 있다. 마을에 있는 물건을 배송하기 위한 트럭 한 대가 있고, 트럭이 있는 본부는 1번 마을 왼쪽에 있다. 이 트럭은 본부에서 출발하여 1번 마을부터 마지막 마을까지 오른쪽으로 가면서 마을에 있는 물건을 배송한다. </p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/bfa825aa-3abf-4012-96bf-55af2f76fb26/-/preview/" style="width: 236px; height: 92px;"></p>

<p>각 마을은 배송할 물건들을 박스에 넣어 보내며, 본부에서는 박스를 보내는 마을번호, 박스를 받는 마을번호와 보낼 박스의 개수를 알고 있다. 박스들은 모두 크기가 같다. 트럭에 최대로 실을 수 있는 박스의 개수, 즉 트럭의 용량이 있다. 이 트럭 한대를 이용하여 다음의 조건을 모두 만족하면서 최대한 많은 박스들을 배송하려고 한다.</p>

<ul>
	<li>조건 1: 박스를 트럭에 실으면, 이 박스는 받는 마을에서만 내린다.</li>
	<li>조건 2: 트럭은 지나온 마을로 되돌아가지 않는다.</li>
	<li>조건 3: 박스들 중 일부만 배송할 수도 있다.</li>
</ul>

<p>마을의 개수, 트럭의 용량, 박스 정보(보내는 마을번호, 받는 마을번호, 박스 개수)가 주어질 때, 트럭 한 대로 배송할 수 있는 최대 박스 수를 구하는 프로그램을 작성하시오. 단, 받는 마을번호는 보내는 마을번호보다 항상 크다.</p>

<p>예를 들어, 트럭 용량이 40이고 보내는 박스들이 다음 표와 같다고 하자.</p>

<table class="table table-bordered" style="width:30%;">
	<thead>
		<tr>
			<th style="width:10%">보내는 마을</th>
			<th style="width:10%">받는 마을</th>
			<th style="width:10%">박스 개수</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>2</td>
			<td>10</td>
		</tr>
		<tr>
			<td>1</td>
			<td>3</td>
			<td>20</td>
		</tr>
		<tr>
			<td>1</td>
			<td>4</td>
			<td>30</td>
		</tr>
		<tr>
			<td>2</td>
			<td>3</td>
			<td>10</td>
		</tr>
		<tr>
			<td>2</td>
			<td>4</td>
			<td>20</td>
		</tr>
		<tr>
			<td>3</td>
			<td>4</td>
			<td>20</td>
		</tr>
	</tbody>
</table>

<p>이들 박스에 대하여 다음과 같이 배송하는 방법을 고려해 보자.</p>

<p>(1) 1번 마을에 도착하면</p>

<ul>
	<li>다음과 같이 박스들을 트럭에 싣는다. (1번 마을에서 4번 마을로 보내는 박스는 30개 중 10개를 싣는다.)</li>
</ul>

<table class="table table-bordered" style="width:30%;">
	<thead>
		<tr>
			<th style="width: 10%;">보내는 마을</th>
			<th style="width: 10%;">받는 마을</th>
			<th style="width: 10%;">박스 개수</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>2</td>
			<td>10</td>
		</tr>
		<tr>
			<td>1</td>
			<td>3</td>
			<td>20</td>
		</tr>
		<tr>
			<td>1</td>
			<td>4</td>
			<td>10</td>
		</tr>
	</tbody>
</table>

<p>(2) 2번 마을에 도착하면</p>

<ul>
	<li>트럭에 실려진 박스들 중 받는 마을번호가 2인 박스 10개를 내려 배송한다. (이때 트럭에 남아있는 박스는 30개가 된다.)</li>
	<li>그리고 다음과 같이 박스들을 싣는다. (이때 트럭에 실려 있는 박스는 40개가 된다.)</li>
</ul>

<table class="table table-bordered" style="width:30%;">
	<thead>
		<tr>
			<th style="width: 10%;">보내는 마을</th>
			<th style="width: 10%;">받는 마을</th>
			<th style="width: 10%;">박스 개수</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>2</td>
			<td>3</td>
			<td>10</td>
		</tr>
	</tbody>
</table>

<p>(3) 3번 마을에 도착하면 </p>

<ul>
	<li>트럭에 실려진 박스들 중 받는 마을번호가 3인 박스 30개를 내려 배송한다. (이때 트럭에 남아있는 박스는 10개가 된다.)</li>
	<li>그리고 다음과 같이 박스들을 싣는다. (이때 트럭에 실려 있는 박스는 30개가 된다.)</li>
</ul>

<table class="table table-bordered" style="width:30%;">
	<thead>
		<tr>
			<th style="width: 10%;">보내는 마을</th>
			<th style="width: 10%;">받는 마을</th>
			<th style="width: 10%;">박스 개수</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>3</td>
			<td>4</td>
			<td>20</td>
		</tr>
	</tbody>
</table>

<p>(4) 4번 마을에 도착하면 </p>

<ul>
	<li>받는 마을번호가 4인 박스 30개를 내려 배송한다</li>
</ul>

<p>위와 같이 배송하면 배송한 전체 박스는 70개이다. 이는 배송할 수 있는 최대 박스 개수이다.</p>

### 입력 

 <p>입력의 첫 줄은 마을 수 N과 트럭의 용량 C가 빈칸을 사이에 두고 주어진다. N은 2이상 2,000이하 정수이고, C는 1이상 10,000이하 정수이다. 다음 줄에, 보내는 박스 정보의 개수 M이 주어진다. M은 1이상 10,000이하 정수이다. 다음 M개의 각 줄에 박스를 보내는 마을번호, 박스를 받는 마을번호, 보내는 박스 개수(1이상 10,000이하 정수)를 나타내는 양의 정수가 빈칸을 사이에 두고 주어진다. 박스를 받는 마을번호는 보내는 마을번호보다 크다. </p>

### 출력 

 <p>트럭 한 대로 배송할 수 있는 최대 박스 수를 한 줄에 출력한다.</p>

## **풀이**
### 접근
핵심은 **이동 구간 동안 용량을 얼마나 오래 잡아먹느냐**입니다.

그러기에 멀리가는 택배보다 빨리 처리할 수 있는 택배를 먼저 배달하는 게 가장 최선이라는 **그리디**를 발견할 수 있습니다.

### 정렬
가장 가까운 곳부터 배달하는 게 가장 빠르므로 **도착 마을 기준으로 오름차순 정렬**을 합니다.

### 구간 용량 설정
택배를 관리하기 위해서 구간 배열을 만들어서 관리해 줍니다. 각 마을단위로 트럭이 실은 용량의 **최대 사용량** 찾아 트럭이 실을 수 있는 용량에서 빼준 용량과 마을에서 요구하는 용량의 **최솟값**을 트럭에 실어줍니다.

트럭에 가장 빠르게 배달할 수 있는 택배를 실었다면 구간에도 적용해서 용량을 갱신해 줍니다.

### 세그먼트 트리 + Lazy Propagation
최대 사용량과 구간 값 수정을 **세그먼트 트리 + Lazy Propagation**를 통해 구현한다면 $\mathcal{O}(\log N)$로 더 빠르게 실행이 가능합니다.

## **구현**
<details markdown="1">
<summary>코드</summary>

```python
import sys
def print(*args, sep=" ", end="\n"): sys.stdout.write(sep.join(map(str, args)) + end)
def input(): return sys.stdin.readline().rstrip()

def main():
    n, c = map(int, input().split())
    m = int(input())
    d = sorted([tuple(map(int, input().split())) for _ in range(m)], key=lambda x: x[1])
    cap = [0] * (n+1)
    ans = 0
    for s, e, w in d:
        can = min(w, c-max(cap[s:e]))
        for i in range(s, e): cap[i] += can
        ans += can
    print(ans)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using aiii = array<int, 3>;

struct SegTree {
    int n;
    vector<int> tree, lazy;
    SegTree(int n) : n(n) {
        tree.assign(4*n, 0);
        lazy.assign(4*n, 0);
    }

    void push(int node) {
        if (lazy[node] != 0) {
            for (int nxt : {node*2, node*2+1}) {
                tree[nxt] += lazy[node];
                lazy[nxt] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void range_add(int node, int l, int r, int ql, int qr, int val) {
        if (qr < l || r < ql) return;
        if (ql <= l && r <= qr) {
            tree[node] += val;
            lazy[node] += val;
            return;
        }
        push(node);
        int mid = (l + r) / 2;
        range_add(node*2, l, mid, ql, qr, val);
        range_add(node*2+1, mid+1, r, ql, qr, val);
        tree[node] = max(tree[node*2], tree[node*2+1]);
    }

    int query_max(int node, int l, int r, int ql, int qr) {
        if (qr < l || r < ql) return 0;
        if (ql <= l && r <= qr) return tree[node];
        push(node);
        int mid = (l + r) / 2;
        return max(
            query_max(node*2, l, mid, ql, qr),
            query_max(node*2+1, mid+1, r, ql, qr)
        );
    }
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, c, m; cin >> n >> c >> m;
    vector<aiii> d(m);
    for(int i = 0; i < m; i++) cin >> d[i][0] >> d[i][1] >> d[i][2];
    sort(d.begin(), d.end(), [](const aiii& a, const aiii& b){
        return a[1] < b[1];
    });
    SegTree seg(n);
    int ans = 0;
    for(auto &[s, e, w]: d){
        int mx = seg.query_max(1, 1, n, s, e-1);
        int can = min(w, c-mx);
        seg.range_add(1, 1, n, s, e-1, can);
        ans += can;
    }
    cout << ans;
    return 0;
}
```
### 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(M·log N)$
* 공간복잡도: $\mathcal{O}(4N)$
